# Code-Ana

词法分析 Lexical Analysis / 函数层次的CFG抽取 CFG Extraction / 同源性检测 Homology Detection / 代码漏洞检测 Vulnerability Detection



## Features

- GUI用QT编写；核心部分利用C++ STL实现，可独立运行
- 分析的目标语言为C / Simple C++
- 利用词法分析和函数层级的CFG抽取进行代码的同源性检测
- AC自动机扫描得到可能存在漏洞的函数，并根据自定义规则报告漏洞



## 功能

- R1：GUI
- R2：利用字符串匹配进行同源性检测
- R3：利用控制流程图（CFG）进行同源性检测
- A2：支持分布式任务调度
- R4: 栈缓冲区检测
- B1: 堆缓冲区检测
- R5: 格式化字符串漏洞检测
- B2: 整数宽度溢出检测
- B3: 整数运算溢出检测
- B4: 整数符号溢出检测



## R1: GUI

QT实现。



## R2: 利用字符串匹配进行同源性检测

利用确定有限状态自动机（Deterministic Finite Automaton， DFA）进行词法分析，将程序转换为token形成的行链表。得到源代码和目标代码的token行链表后，利用时间复杂度为O(nm)、空间复杂度为O(n)的动态规划算法，得到所有行数大于阈值的公共代码块，根据代码块的总长度计算代码之间的相似度。



## R3: 利用控制流程图（CFG）进行同源性检测

首先扫描代码得到函数信息，包括函数ID、起始位置、结束位置。再次扫描代码，得到函数调用关系。考虑可能的代码跳转情况，将执行代码对应的token顺序连接，形成CFG对应的工作流程。利用时间复杂度为O(nm)、空间复杂度为O(n)的动态规划算法，得到所有token个数大于阈值的公共代码块，根据公共代码块的总长度计算代码之间的相似度。



## A2: 支持分布式任务调度

利用C++11的thread类和QT的signals & slots机制实现。线程完成子任务后，发出signals返回执行结果；主线程slots逐一处理队列中的signals。



## R4: 栈缓冲区检测 & B1: 堆缓冲区检测

扫描代码得到函数信息，包括函数ID、起始位置、结束位置、函数调用过程中涉及的变量信息。其中变量信息包括函数名、作用域起始偏移、末尾偏移、代码块深度以及类型、字节大小（对数组额外记录数组长度，对指针额外记录指针所指位置以及可用空间的数组长度）。

对每一个函数内部进行扫描，扫描过程中维护当前变量，结合AC自动机判断是否存在敏感函数调用。对敏感函数，根据预设的规则返回函数偏移、函数名称、漏洞信息、危险等级、漏洞类型。扫描过程中也关注malloc、calloc、realloc、free等内存管理函数，维护指针的位置信息（栈or堆）和其所指的可用空间长度信息。

对缓冲区溢出漏洞，根据相关变量的位置（栈or堆），将漏洞类型分为栈缓冲区溢出漏洞和堆缓冲区溢出漏洞。



## R5: 格式化字符串漏洞检测

扫描过程与R4 / B1相同，对格式化字符串函数（敏感函数）进行参数个数检测、参数类型检测、控制符%n检测，根据预设的规则返回函数偏移、函数名称、漏洞信息、危险等级、漏洞类型。



## B2: 整数宽度溢出检测

检测赋值运算的右表达式中是否存在宽度大于左值的变量，存在则报错。



## B3: 整数运算溢出检测

检测整数运算中是否存在乘法，若存在则报错。



## B4: 整数符号溢出检测

一方面检测赋值运算的右表达式是否存在符号与左值不同的变量，存在则报错；另一方面检测敏感函数的无符号参数是否存在从有符号数到无符号数的隐式转换，存在则报错。



## TODO

- 敏感函数参数的隐式转换
- 敏感函数参数的漏洞检测（符号、运算）
- 增加代码行号显示
- 存在漏洞的代码高亮
- CFG可视化
- 更详细的漏洞信息输出